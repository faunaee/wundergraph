import { Template, TemplateOutputFile, visitJSONSchema } from '../../index';
import { ResolvedWunderGraphConfig } from '../../../configure';
import { hasInput } from '../typescript/react';
import { JSONSchema7 as JSONSchema, JSONSchema7 } from 'json-schema';
import { BaseTypeScriptDataModel } from '../typescript';
import execa from 'execa';

const golangHeader = (packageName: string) =>
	`// Code generated by wunderctl. DO NOT EDIT.\npackage ${packageName}\n\n`;

const gofmt = (code: string) => {
	try {
		// check if gofmt is installed
		const formatter = execa.sync('gofmt', {
			input: code,
			encoding: 'utf8',
		});
		if (formatter.exitCode === 0) {
			return formatter.stdout;
		}
	} catch (e: any) {
		console.error(e);
	}
	return code;
};

export class GolangInputModels implements Template {
	constructor({ packageName }: { packageName: string } = { packageName: 'client' }) {
		this.packageName = packageName;
	}

	private readonly packageName: string;

	async generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		const content = config.application.Operations.filter(hasInput)
			.map((op) => JSONSchemaToGolangStruct(op.VariablesSchema, op.Name + 'Input', false))
			.join('\n\n');
		return Promise.resolve([
			{
				path: 'models.go',
				content: gofmt(content),
				header: golangHeader(this.packageName),
			},
		]);
	}

	dependencies(): Template[] {
		return [new GolangModelsBase()];
	}
}

export class GolangResponseModels implements Template {
	constructor({ packageName }: { packageName: string } = { packageName: 'client' }) {
		this.packageName = packageName;
	}

	private readonly packageName: string;

	generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		const content = config.application.Operations.map((op) => {
			const dataName = '#/definitions/' + op.Name + 'ResponseData';
			const responseSchema = JSON.parse(JSON.stringify(op.ResponseSchema)) as JSONSchema7;
			if (responseSchema.properties) {
				responseSchema.properties['data'] = {
					$ref: dataName,
				};
			}
			return JSONSchemaToGolangStruct(responseSchema, op.Name + 'Response', true);
		}).join('\n\n');
		return Promise.resolve([
			{
				path: 'models.go',
				content: gofmt(content),
				header: golangHeader(this.packageName),
			},
		]);
	}

	dependencies(): Template[] {
		return [new GolangModelsBase(), new GolangResponseDataModels(), new GolangBaseDataModel()];
	}
}

export class GolangResponseDataModels implements Template {
	generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		const content = config.application.Operations.filter(
			(op) => op.ResponseSchema.properties !== undefined && op.ResponseSchema.properties['data'] !== undefined
		)
			.map((op) =>
				JSONSchemaToGolangStruct(op.ResponseSchema.properties!['data'] as JSONSchema7, op.Name + 'ResponseData', false)
			)
			.join('\n\n');
		return Promise.resolve([
			{
				path: 'models.go',
				content: gofmt(content),
				header: golangHeader('client'),
			},
		]);
	}

	dependencies(): Template[] {
		return [new BaseTypeScriptDataModel()];
	}
}

export class GolangBaseDataModel implements Template {
	constructor({ packageName }: { packageName: string } = { packageName: 'client' }) {
		this.packageName = packageName;
	}

	private readonly packageName: string;

	generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		const definitions: Map<string, JSONSchema7> = new Map();

		config.application.Operations.forEach((op) => {
			if (!op.VariablesSchema.definitions) {
				return;
			}
			Object.keys(op.VariablesSchema.definitions).forEach((definitionName) => {
				if (definitions.has(definitionName)) {
					return;
				}
				const definition = op.VariablesSchema.definitions![definitionName];
				if (typeof definition !== 'object') {
					return;
				}
				definitions.set(definitionName, definition);
			});
		});

		const content = Array.from(definitions.entries())
			.map(([definitionName, definition]) => JSONSchemaToGolangStruct(definition, definitionName, false))
			.join('\n\n');

		return Promise.resolve([
			{
				path: 'models.go',
				content: gofmt(content),
				header: golangHeader(this.packageName),
			},
		]);
	}
}

const golangModelsBase = `

type GraphQLError struct {
	Message string
	Path    any[]
}

`;

export class GolangModelsBase implements Template {
	async generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		return Promise.resolve([
			{
				path: 'client.go',
				content: golangModelsBase,
			},
		]);
	}
}

export class GolangClient implements Template {
	async generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		return Promise.resolve([
			{
				path: 'client.go',
				content: '',
			},
		]);
	}
}

const JSONSchemaToGolangStruct = (schema: JSONSchema, structName: string, withErrors: boolean): string => {
	let out = '';
	visitJSONSchema(schema, {
		root: {
			enter: () => {
				out += `type ${structName} struct {\n`;
			},
			leave: () => {
				out += '}\n';
			},
		},
		number: (name, isRequired, isArray) => {
			out += `\t${name} ${isArray ? '[]' : ''}${isRequired ? '' : '*'}float64\n`;
		},
		array: {
			enter: (name, isRequired, isArray) => {
				out += `\t${name}`;
			},
			leave: (name, isRequired, isArray) => {},
		},
		string: (name, isRequired, isArray, enumValues) => {
			out += `\t${name} ${isArray ? '[]' : ''}${isRequired ? '' : '*'}string\n`;
		},
		object: {
			enter: (name, isRequired, isArray) => {
				out += `\t${name} ${isArray ? '[]' : ''}${isRequired ? '' : '*'}struct {\n`;
			},
			leave: (name, isRequired, isArray) => {
				out += `\t}\n`;
			},
		},
		boolean: (name, isRequired, isArray) => {
			out += `\t${name} ${isArray ? '[]' : ''}${isRequired ? '' : '*'}bool\n`;
		},
		any: (name, isRequired, isArray) => {
			out += `\t${name} ${isArray ? '[]' : ''}${isRequired ? '' : '*'}interface{}\n`;
		},
		customType: (name, typeName, isRequired, isArray) => {
			out += `\t${name} ${isArray ? '[]' : ''} ${isRequired ? '' : '*'}${typeName}\n`;
		},
	});
	return out;
};

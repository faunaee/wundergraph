import { Template, TemplateOutputFile, visitJSONSchema } from '../../index';
import { ResolvedWunderGraphConfig } from '../../../configure';
import { hasInput } from '../typescript/react';
import { JSONSchema7 as JSONSchema, JSONSchema7 } from 'json-schema';
import { BaseTypeScriptDataModel } from '../typescript';
import execa from 'execa';
import _ from 'lodash';

const golangHeader = (packageName: string) =>
	`// Code generated by wunderctl. DO NOT EDIT.\npackage ${packageName}\n\n`;

const gofmt = (code: string) => {
	try {
		// check if gofmt is installed
		const formatter = execa.sync('gofmt', {
			input: code,
			encoding: 'utf8',
		});
		if (formatter.exitCode === 0) {
			return formatter.stdout;
		}
	} catch (e: any) {
		console.error(e);
	}
	return code;
};

export class GolangInputModels implements Template {
	constructor({ packageName }: { packageName: string } = { packageName: 'client' }) {
		this.packageName = packageName;
	}

	private readonly packageName: string;

	async generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		const content = config.application.Operations.filter(hasInput)
			.map((op) => JSONSchemaToGolangStruct(op.VariablesSchema, op.Name + 'Input', false))
			.join('\n\n');
		return Promise.resolve([
			{
				path: 'models.go',
				content: gofmt(content),
				header: golangHeader(this.packageName),
			},
		]);
	}

	dependencies(): Template[] {
		return [new GolangModelsBase()];
	}
}

export class GolangResponseModels implements Template {
	constructor({ packageName }: { packageName: string } = { packageName: 'client' }) {
		this.packageName = packageName;
	}

	private readonly packageName: string;

	generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		const content = config.application.Operations.map((op) => {
			const dataName = '#/definitions/' + op.Name + 'ResponseData';
			const responseSchema = JSON.parse(JSON.stringify(op.ResponseSchema)) as JSONSchema7;
			if (responseSchema.properties) {
				responseSchema.properties['data'] = {
					$ref: dataName,
				};
			}
			return JSONSchemaToGolangStruct(responseSchema, op.Name + 'Response', true);
		}).join('\n\n');
		return Promise.resolve([
			{
				path: 'models.go',
				content: gofmt(content),
				header: golangHeader(this.packageName),
			},
		]);
	}

	dependencies(): Template[] {
		return [new GolangModelsBase(), new GolangResponseDataModels(), new GolangBaseDataModel()];
	}
}

export class GolangResponseDataModels implements Template {
	generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		const content = config.application.Operations.filter(
			(op) => op.ResponseSchema.properties !== undefined && op.ResponseSchema.properties['data'] !== undefined
		)
			.map((op) =>
				JSONSchemaToGolangStruct(op.ResponseSchema.properties!['data'] as JSONSchema7, op.Name + 'ResponseData', false)
			)
			.join('\n\n');
		return Promise.resolve([
			{
				path: 'models.go',
				content: gofmt(content),
				header: golangHeader('client'),
			},
		]);
	}

	dependencies(): Template[] {
		return [new BaseTypeScriptDataModel()];
	}
}

export class GolangBaseDataModel implements Template {
	constructor({ packageName }: { packageName: string } = { packageName: 'client' }) {
		this.packageName = packageName;
	}

	private readonly packageName: string;

	generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		const definitions: Map<string, JSONSchema7> = new Map();

		config.application.Operations.forEach((op) => {
			if (!op.VariablesSchema.definitions) {
				return;
			}
			Object.keys(op.VariablesSchema.definitions).forEach((definitionName) => {
				if (definitions.has(definitionName)) {
					return;
				}
				const definition = op.VariablesSchema.definitions![definitionName];
				if (typeof definition !== 'object') {
					return;
				}
				definitions.set(definitionName, definition);
			});
		});

		const content = Array.from(definitions.entries())
			.map(([definitionName, definition]) => JSONSchemaToGolangStruct(definition, definitionName, false))
			.join('\n\n');

		return Promise.resolve([
			{
				path: 'models.go',
				content: gofmt(content),
				header: golangHeader(this.packageName),
			},
		]);
	}
}

const golangModelsBase = `
type GraphQLError struct {
	Message string
	Path    []interface{}
}`;

export class GolangModelsBase implements Template {
	async generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		return Promise.resolve([
			{
				path: 'models.go',
				content: gofmt(golangModelsBase),
			},
		]);
	}
}

export class GolangClient implements Template {
	constructor({ packageName }: { packageName: string } = { packageName: 'client' }) {
		this.packageName = packageName;
	}

	private readonly packageName: string;

	async generate(config: ResolvedWunderGraphConfig): Promise<TemplateOutputFile[]> {
		return Promise.resolve([
			{
				path: 'client.go',
				content: '',
				header: golangHeader(this.packageName),
			},
		]);
	}
}

const JSONSchemaToGolangStruct = (schema: JSONSchema, structName: string, withErrors: boolean): string => {
	let out = '';
	const capitalize = (name: string) => _.capitalize(name.substring(0, 1)) + name.substring(1);
	visitJSONSchema(schema, {
		root: {
			enter: () => {
				out += `type ${capitalize(structName)} struct {\n`;
			},
			leave: () => {
				if (withErrors) {
					out += `\terrors []GraphQLError \`json:"errors"\``;
				}
				out += '\n}\n';
			},
		},
		number: (name, isRequired, isArray) => {
			out += `\t${capitalize(name)} ${isArray ? '[]' : ''}${
				isRequired ? '' : '*'
			}float64 \`json:"${name},omitempty"\`\n`;
		},
		array: {
			enter: (name, isRequired, isArray) => {
				out += `\t${capitalize(name)}`;
			},
			leave: (name, isRequired, isArray) => {
				if (name) {
					out += `\`json:"${name},omitempty"\` `;
				}
			},
		},
		string: (name, isRequired, isArray, enumValues) => {
			if (isArray) {
				out += `\t${capitalize(name)} ${isArray ? '[]' : ''}${isRequired ? '' : '*'}string `;
			} else {
				out += `\t${capitalize(name)} ${isArray ? '[]' : ''}${
					isRequired ? '' : '*'
				}string \`json:"${name},omitempty"\`\n`;
			}
		},
		object: {
			enter: (name, isRequired, isArray) => {
				out += `\t${capitalize(name)} ${isArray ? '[]' : ''}${isRequired ? '' : '*'}struct {\n`;
			},
			leave: (name, isRequired, isArray) => {
				if (isArray) {
					out += ' } ';
					return;
				}
				out += `\t} \`json:"${name},omitempty"\`\n`;
			},
		},
		boolean: (name, isRequired, isArray) => {
			out += `\t${capitalize(name)} ${isArray ? '[]' : ''}${isRequired ? '' : '*'}bool \`json:"${name},omitempty"\`\n`;
		},
		any: (name, isRequired, isArray) => {
			out += `\t${capitalize(name)} ${isArray ? '[]' : ''}${
				isRequired ? '' : '*'
			}interface{} \`json:"${name},omitempty"\`\n`;
		},
		customType: (name, typeName, isRequired, isArray) => {
			out += `\t${capitalize(name)} ${isArray ? '[]' : ''} ${isRequired ? '' : '*'}${capitalize(
				typeName
			)} \`json:"${name},omitempty"\`\n`;
		},
	});
	return out;
};
